package MODELS;

import com.datastax.oss.driver.api.core.CqlIdentifier;
import com.datastax.oss.driver.api.core.data.GettableByName;
import com.datastax.oss.driver.api.core.data.SettableByName;
import com.datastax.oss.driver.api.core.data.UdtValue;
import com.datastax.oss.driver.api.core.metadata.schema.KeyspaceMetadata;
import com.datastax.oss.driver.api.core.metadata.schema.TableMetadata;
import com.datastax.oss.driver.api.core.type.DataType;
import com.datastax.oss.driver.api.core.type.ListType;
import com.datastax.oss.driver.api.core.type.UserDefinedType;
import com.datastax.oss.driver.api.core.type.reflect.GenericType;
import com.datastax.oss.driver.api.mapper.MapperContext;
import com.datastax.oss.driver.api.mapper.MapperException;
import com.datastax.oss.driver.api.mapper.entity.saving.NullSavingStrategy;
import com.datastax.oss.driver.api.querybuilder.QueryBuilder;
import com.datastax.oss.driver.api.querybuilder.delete.Delete;
import com.datastax.oss.driver.api.querybuilder.delete.DeleteSelection;
import com.datastax.oss.driver.api.querybuilder.insert.InsertInto;
import com.datastax.oss.driver.api.querybuilder.insert.RegularInsert;
import com.datastax.oss.driver.api.querybuilder.relation.Relation;
import com.datastax.oss.driver.api.querybuilder.select.Select;
import com.datastax.oss.driver.api.querybuilder.select.SelectFrom;
import com.datastax.oss.driver.api.querybuilder.update.UpdateStart;
import com.datastax.oss.driver.internal.mapper.entity.EntityHelperBase;
import com.datastax.oss.driver.internal.querybuilder.update.DefaultUpdate;
import com.datastax.oss.driver.shaded.guava.common.collect.ImmutableList;
import com.datastax.oss.driver.shaded.guava.common.collect.Lists;
import java.lang.Class;
import java.lang.IllegalArgumentException;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generated by the DataStax driver mapper, do not edit directly.
 */
@SuppressWarnings("all")
public class OrderByCustomerHelper__MapperGenerated extends EntityHelperBase<OrderByCustomer> {
  private static final Logger LOG = LoggerFactory.getLogger(OrderByCustomerHelper__MapperGenerated.class);

  private static final GenericType<List<UdtValue>> GENERIC_TYPE = new GenericType<List<UdtValue>>(){};

  private static final GenericType<String> GENERIC_TYPE1 = new GenericType<String>(){};

  private static final GenericType<Instant> GENERIC_TYPE2 = new GenericType<Instant>(){};

  private static final GenericType<BigDecimal> GENERIC_TYPE3 = new GenericType<BigDecimal>(){};

  private static final GenericType<UUID> GENERIC_TYPE4 = new GenericType<UUID>(){};

  private final List<String> primaryKeys;

  private final OrderItemHelper__MapperGenerated orderItemHelper;

  public OrderByCustomerHelper__MapperGenerated(MapperContext context) {
    super(context, "orders_by_customer");
    LOG.debug("[{}] Entity OrderByCustomer will be mapped to {}{}",
        context.getSession().getName(),
        getKeyspaceId() == null ? "" : getKeyspaceId() + ".",
        getTableId());
    this.primaryKeys = ImmutableList.<String>builder()
        .add("customer_id")
        .add("yyyy_mm")
        .add("order_date")
        .add("order_id")
        .build();
    this.orderItemHelper = new OrderItemHelper__MapperGenerated(context);
  }

  @Override
  public Class<OrderByCustomer> getEntityClass() {
    return OrderByCustomer.class;
  }

  @Override
  public <SettableT extends SettableByName<SettableT>> SettableT set(OrderByCustomer entity,
      SettableT target, NullSavingStrategy nullSavingStrategy, boolean lenient) {
    if (!lenient || hasProperty(target, "customer_id")) {
      if (entity.getCustomerId() != null || nullSavingStrategy == NullSavingStrategy.SET_TO_NULL) {
        target = target.set("customer_id", entity.getCustomerId(), UUID.class);
      }
    }
    if (!lenient || hasProperty(target, "yyyy_mm")) {
      if (entity.getYearMonth() != null || nullSavingStrategy == NullSavingStrategy.SET_TO_NULL) {
        target = target.set("yyyy_mm", entity.getYearMonth(), String.class);
      }
    }
    if (!lenient || hasProperty(target, "order_date")) {
      if (entity.getOrderDate() != null || nullSavingStrategy == NullSavingStrategy.SET_TO_NULL) {
        target = target.set("order_date", entity.getOrderDate(), Instant.class);
      }
    }
    if (!lenient || hasProperty(target, "order_id")) {
      if (entity.getOrderId() != null || nullSavingStrategy == NullSavingStrategy.SET_TO_NULL) {
        target = target.set("order_id", entity.getOrderId(), UUID.class);
      }
    }
    if (!lenient || hasProperty(target, "total")) {
      if (entity.getTotal() != null || nullSavingStrategy == NullSavingStrategy.SET_TO_NULL) {
        target = target.set("total", entity.getTotal(), BigDecimal.class);
      }
    }
    if (!lenient || hasProperty(target, "items")) {
      List<OrderItem> mappedCollection = entity.getItems();
      if (mappedCollection != null) {
        UserDefinedType orderItemUdtType = (UserDefinedType) ((ListType) target.getType("items")).getElementType();
        List<UdtValue> rawCollection = Lists.newArrayListWithExpectedSize(mappedCollection.size());
        for (OrderItem mappedElement: mappedCollection) {
          UdtValue rawElement = orderItemUdtType.newValue();
          orderItemHelper.set(mappedElement, rawElement, NullSavingStrategy.DO_NOT_SET, lenient);
          rawCollection.add(rawElement);
        }
        target = target.set("items", rawCollection, GENERIC_TYPE);
      } else if (nullSavingStrategy == NullSavingStrategy.SET_TO_NULL) {
        target = target.set("items", null, GENERIC_TYPE);
      }
    }
    if (!lenient || hasProperty(target, "status")) {
      if (entity.getStatus() != null || nullSavingStrategy == NullSavingStrategy.SET_TO_NULL) {
        target = target.set("status", entity.getStatus(), String.class);
      }
    }
    return target;
  }

  @Override
  public OrderByCustomer get(GettableByName source, boolean lenient) {
    OrderByCustomer returnValue = new OrderByCustomer();
    if (!lenient || hasProperty(source, "customer_id")) {
      UUID propertyValue = source.get("customer_id", UUID.class);
      returnValue.setCustomerId(propertyValue);
    }
    if (!lenient || hasProperty(source, "yyyy_mm")) {
      String propertyValue1 = source.get("yyyy_mm", String.class);
      returnValue.setYearMonth(propertyValue1);
    }
    if (!lenient || hasProperty(source, "order_date")) {
      Instant propertyValue2 = source.get("order_date", Instant.class);
      returnValue.setOrderDate(propertyValue2);
    }
    if (!lenient || hasProperty(source, "order_id")) {
      UUID propertyValue3 = source.get("order_id", UUID.class);
      returnValue.setOrderId(propertyValue3);
    }
    if (!lenient || hasProperty(source, "total")) {
      BigDecimal propertyValue4 = source.get("total", BigDecimal.class);
      returnValue.setTotal(propertyValue4);
    }
    if (!lenient || hasProperty(source, "items")) {
      List<OrderItem> propertyValue5;
      List<UdtValue> rawCollection1 = source.get("items", GENERIC_TYPE);
      if (rawCollection1 == null) {
        propertyValue5 = null;
      } else {
        propertyValue5 = Lists.newArrayListWithExpectedSize(rawCollection1.size());
        for (UdtValue rawElement1: rawCollection1) {
          OrderItem mappedElement1;
          mappedElement1 = orderItemHelper.get(rawElement1, lenient);
          propertyValue5.add(mappedElement1);
        }
      }
      returnValue.setItems(propertyValue5);
    }
    if (!lenient || hasProperty(source, "status")) {
      String propertyValue6 = source.get("status", String.class);
      returnValue.setStatus(propertyValue6);
    }
    return returnValue;
  }

  @Override
  public RegularInsert insert() {
    throwIfKeyspaceMissing();
    InsertInto insertInto = (keyspaceId == null)
        ? QueryBuilder.insertInto(tableId)
        : QueryBuilder.insertInto(keyspaceId, tableId);
    return insertInto
        .value("customer_id", QueryBuilder.bindMarker("customer_id"))
        .value("yyyy_mm", QueryBuilder.bindMarker("yyyy_mm"))
        .value("order_date", QueryBuilder.bindMarker("order_date"))
        .value("order_id", QueryBuilder.bindMarker("order_id"))
        .value("total", QueryBuilder.bindMarker("total"))
        .value("items", QueryBuilder.bindMarker("items"))
        .value("status", QueryBuilder.bindMarker("status"));
  }

  public Select selectByPrimaryKeyParts(int parameterCount) {
    Select select = selectStart();
    for (int i = 0; i < parameterCount && i < primaryKeys.size(); i++) {
      String columnName = primaryKeys.get(i);
      select = select.whereColumn(columnName).isEqualTo(QueryBuilder.bindMarker(columnName));
    }
    return select;
  }

  @Override
  public Select selectByPrimaryKey() {
    return selectByPrimaryKeyParts(primaryKeys.size());
  }

  @Override
  public Select selectStart() {
    throwIfKeyspaceMissing();
    SelectFrom selectFrom = (keyspaceId == null)
        ? QueryBuilder.selectFrom(tableId)
        : QueryBuilder.selectFrom(keyspaceId, tableId);
    return selectFrom
        .column("customer_id")
        .column("yyyy_mm")
        .column("order_date")
        .column("order_id")
        .column("total")
        .column("items")
        .column("status");
  }

  public DeleteSelection deleteStart() {
    throwIfKeyspaceMissing();
    return (keyspaceId == null)
        ? QueryBuilder.deleteFrom(tableId)
        : QueryBuilder.deleteFrom(keyspaceId, tableId);
  }

  public Delete deleteByPrimaryKeyParts(int parameterCount) {
    if (parameterCount <= 0) {
      throw new MapperException("parameterCount must be greater than 0");
    }
    DeleteSelection deleteSelection = deleteStart();
    String columnName = primaryKeys.get(0);
    Delete delete = deleteSelection.whereColumn(columnName).isEqualTo(QueryBuilder.bindMarker(columnName));
    for (int i = 1; i < parameterCount && i < primaryKeys.size(); i++) {
      columnName = primaryKeys.get(i);
      delete = delete.whereColumn(columnName).isEqualTo(QueryBuilder.bindMarker(columnName));
    }
    return delete;
  }

  @Override
  public Delete deleteByPrimaryKey() {
    return deleteByPrimaryKeyParts(primaryKeys.size());
  }

  @Override
  public DefaultUpdate updateStart() {
    throwIfKeyspaceMissing();
    UpdateStart update = (keyspaceId == null)
        ? QueryBuilder.update(tableId)
        : QueryBuilder.update(keyspaceId, tableId);
    return ((DefaultUpdate)update
        .setColumn("total", QueryBuilder.bindMarker("total"))
        .setColumn("items", QueryBuilder.bindMarker("items"))
        .setColumn("status", QueryBuilder.bindMarker("status")));
  }

  @Override
  public DefaultUpdate updateByPrimaryKey() {
    return ((DefaultUpdate)updateStart()
        .where(Relation.column("customer_id").isEqualTo(QueryBuilder.bindMarker("customer_id")))
        .where(Relation.column("yyyy_mm").isEqualTo(QueryBuilder.bindMarker("yyyy_mm")))
        .where(Relation.column("order_date").isEqualTo(QueryBuilder.bindMarker("order_date")))
        .where(Relation.column("order_id").isEqualTo(QueryBuilder.bindMarker("order_id"))));
  }

  @Override
  public void validateEntityFields() {
    CqlIdentifier keyspaceId = this.keyspaceId != null ? this.keyspaceId : context.getSession().getKeyspace().orElse(null);
    String entityClassName = "MODELS.OrderByCustomer";
    if (keyspaceId == null) {
      LOG.warn("[{}] Unable to validate table: {} for the entity class: {} because the keyspace is unknown (the entity does not declare a default keyspace, and neither the session nor the DAO were created with a keyspace). The DAO will only work if it uses fully-qualified queries with @Query or @QueryProvider.",
          context.getSession().getName(),
          tableId,
          entityClassName);
      return;
    }
    if(!keyspaceNamePresent(context.getSession().getMetadata().getKeyspaces(), keyspaceId)) {
      LOG.warn("[{}] Unable to validate table: {} for the entity class: {} because the session metadata has no information about the keyspace: {}.",
          context.getSession().getName(),
          tableId,
          entityClassName,
          keyspaceId);
      return;
    }
    Optional<KeyspaceMetadata> keyspace = context.getSession().getMetadata().getKeyspace(keyspaceId);
    List<CqlIdentifier> expectedCqlNames = new ArrayList<>();
    expectedCqlNames.add(CqlIdentifier.fromCql("customer_id"));
    expectedCqlNames.add(CqlIdentifier.fromCql("yyyy_mm"));
    expectedCqlNames.add(CqlIdentifier.fromCql("order_date"));
    expectedCqlNames.add(CqlIdentifier.fromCql("order_id"));
    expectedCqlNames.add(CqlIdentifier.fromCql("total"));
    expectedCqlNames.add(CqlIdentifier.fromCql("items"));
    expectedCqlNames.add(CqlIdentifier.fromCql("status"));
    Optional<TableMetadata> tableMetadata = keyspace.flatMap(v -> v.getTable(tableId));
    Optional<UserDefinedType> userDefinedType = keyspace.flatMap(v -> v.getUserDefinedType(tableId));
    if (tableMetadata.isPresent()) {
      // validation of missing Clustering Columns
      List<CqlIdentifier> expectedCqlClusteringColumns = new ArrayList<>();
      expectedCqlClusteringColumns.add(CqlIdentifier.fromCql("order_date"));
      expectedCqlClusteringColumns.add(CqlIdentifier.fromCql("order_id"));
      List<CqlIdentifier> missingTableClusteringColumnNames = findMissingColumns(expectedCqlClusteringColumns, tableMetadata.get().getClusteringColumns().keySet());
      if (!missingTableClusteringColumnNames.isEmpty()) {
        throw new IllegalArgumentException(String.format("The CQL ks.table: %s.%s has missing Clustering columns: %s that are defined in the entity class: %s", keyspaceId, tableId, missingTableClusteringColumnNames, entityClassName));
      }
      // validation of missing PKs
      List<CqlIdentifier> expectedCqlPKs = new ArrayList<>();
      expectedCqlPKs.add(CqlIdentifier.fromCql("customer_id"));
      expectedCqlPKs.add(CqlIdentifier.fromCql("yyyy_mm"));
      List<CqlIdentifier> missingTablePksNames = findMissingColumns(expectedCqlPKs, tableMetadata.get().getPartitionKey());
      if (!missingTablePksNames.isEmpty()) {
        throw new IllegalArgumentException(String.format("The CQL ks.table: %s.%s has missing Primary Key columns: %s that are defined in the entity class: %s", keyspaceId, tableId, missingTablePksNames, entityClassName));
      }
      // validation of all columns
      List<CqlIdentifier> missingTableCqlNames = findMissingCqlIdentifiers(expectedCqlNames, tableMetadata.get().getColumns().keySet());
      if (!missingTableCqlNames.isEmpty()) {
        throw new IllegalArgumentException(String.format("The CQL ks.table: %s.%s has missing columns: %s that are defined in the entity class: %s", keyspaceId, tableId, missingTableCqlNames, entityClassName));
      }
      // validation of types
      Map<CqlIdentifier, GenericType<?>> expectedTypesPerColumn = new LinkedHashMap<>();
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("yyyy_mm"), GENERIC_TYPE1);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("items"), GENERIC_TYPE);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("order_date"), GENERIC_TYPE2);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("total"), GENERIC_TYPE3);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("order_id"), GENERIC_TYPE4);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("status"), GENERIC_TYPE1);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("customer_id"), GENERIC_TYPE4);
      List<String> missingTableTypes = findTypeMismatches(expectedTypesPerColumn, tableMetadata.get().getColumns(), context.getSession().getContext().getCodecRegistry());
      throwMissingTableTypesIfNotEmpty(missingTableTypes, keyspaceId, tableId, entityClassName);
    }
    else if (userDefinedType.isPresent()) {
      // validation of UDT columns
      List<CqlIdentifier> columns = userDefinedType.get().getFieldNames();
      List<CqlIdentifier> missingTableCqlNames = findMissingCqlIdentifiers(expectedCqlNames, columns);
      if (!missingTableCqlNames.isEmpty()) {
        throw new IllegalArgumentException(String.format("The CQL ks.udt: %s.%s has missing columns: %s that are defined in the entity class: %s", keyspaceId, tableId, missingTableCqlNames, entityClassName));
      }
      // validation of UDT types
      Map<CqlIdentifier, GenericType<?>> expectedTypesPerColumn = new LinkedHashMap<>();
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("yyyy_mm"), GENERIC_TYPE1);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("items"), GENERIC_TYPE);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("order_date"), GENERIC_TYPE2);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("total"), GENERIC_TYPE3);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("order_id"), GENERIC_TYPE4);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("status"), GENERIC_TYPE1);
      expectedTypesPerColumn.put(CqlIdentifier.fromCql("customer_id"), GENERIC_TYPE4);
      List<CqlIdentifier> expectedColumns = userDefinedType.get().getFieldNames();
      List<DataType> expectedTypes = userDefinedType.get().getFieldTypes();
      List<String> missingTableTypes = findTypeMismatches(expectedTypesPerColumn, expectedColumns, expectedTypes, context.getSession().getContext().getCodecRegistry());
      throwMissingUdtTypesIfNotEmpty(missingTableTypes, keyspaceId, tableId, entityClassName);
    }
    // warn if there is not keyspace.table for defined entity - it means that table is missing, or schema it out of date.
    else {
      LOG.warn("[{}] There is no ks.table or UDT: {}.{} for the entity class: {}, or metadata is out of date.",
          context.getSession().getName(),
          keyspaceId,
          tableId,
          entityClassName);
    }
  }
}
